package Local::JSONParser;

use strict;
use warnings;
use base qw(Exporter);
our @EXPORT_OK = qw( parse_json );
our @EXPORT = qw( parse_json );
use utf8;

sub parse_json {
	$_ = shift;
	local $^R;
	my %escape = ('b'=>8,'f'=>12,'n'=>10,'r'=>13,'t'=>9,'"'=>34,"/"=>47,"\\"=>92);
	my $res = m{
		# $^R представляем как стек
		# в стек кладеться последнее вычисленное значение в (?{})
		# работаем по аналогии польской нотации
		# string, рисование array и object - унарная операция
		# key_value, конкатенация array и object - бинарная операция
		(?{[]}) #инициализируем
		(?<number>
			(-?\d+(\.?\d+)*([eE][+-]?\d+)*)
			(?{[@{$^R}, $^N+0]}) #преобразуем в число
		){0}
		(?<string>
			(\"
				(?{[@{$^R}, ""]}) #инициализируем
				((\\u([[:xdigit:]]{4})
					(?{[@{$^R}[0..$#{$^R}-1], "${$^R}[-1]".chr(hex($^N))]}) #декодируем и конкатенируем символы
				)|
				(\\([\"\\/bfnrt])
					(?{[@{$^R}[0..$#{$^R}-1], "${$^R}[-1]".chr($escape{$^N})]}) #заменяем и конкатенируем символы
				)|
				(([^\\"])
					(?{[@{$^R}[0..$#{$^R}-1], "${$^R}[-1]$^N"]}) #конкатенируем символы
				)
			)*+\")
			(?{[@{$^R}[0..$#{$^R}-1], "q(${$^R}[-1])"]}) #рисуем строку
		){0}
		(?<value>
			(?&number)|
			(?&string)|
			(?&array)|
			(?&object)|
			true(?{[@{$^R}, 1]})| #преобразем в perl значения
			false(?{[@{$^R}, 0]})| #преобразем в perl значения
			null(?{[@{$^R}, "undef"]}) #преобразем в perl значения
		){0}
		(?<key_value>
			(\s*(?&string)\s*:\s*(?&value)\s*)
			(?{ [@{$^R}[0..$#{$^R}-2], "${$^R}[-2]=>${$^R}[-1]"] }) #рисуем "жирную запятую" для хэша
		){0}
		(?<array>
			\s*(\[\s*(?&value)(\s*,\s*(?&value)
				(?{ [@{$^R}[0..$#{$^R}-2], "${$^R}[-2],${$^R}[-1]"] }) #конкатенируем значения
				)*\s*\]
				(?{[@{$^R}[0..$#{$^R}-1], "[${$^R}[-1]]"]}) #рисуем массив
			)|
			((\[\s*\])(?{[@{$^R}, "$+"]}))\s*
		){0}
		(?<object>
			\s*(\{\s*(?&key_value)(\s*,\s*(?&key_value)
				(?{ [@{$^R}[0..$#{$^R}-2], "${$^R}[-2],${$^R}[-1]"] }) #конкатенируем значения
				)*\s*\}
				(?{[@{$^R}[0..$#{$^R}-1], "{${$^R}[-1]}"]}) #рисуем хэш
			)|
			((\{\s*\})(?{[@{$^R}, "$+"]}))\s*
		){0}
		^\s*(?<parse>(?&array)|(?&object))\s*$
		(?{$_ = ${$^R}[0]})
	}x;
	return eval($_) if($res);
	die 'Error';

	# use JSON::XS;
	# return JSON::XS->new->utf8->decode($source);
}

1;
